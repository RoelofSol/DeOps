


This is an initial scrap design document

OUT OF SYNCH WITH ACTUAL IMPLEMENTATION

///////////////////////////////////////////////
// code

Second Timer
	if Dht cache dead
		if IP cache empty
			try web cache
			time out 30 minutes
		else
			Send ping to random ip
				Set test firewall flag if in firewall test window
				on pong response send bootstrap 
				(prevents bootstraper from sending bootstrap response that node that cant receive udp)
				
	If in Block or NAT mode
		Try TCP connect to closest key
		Use Dht cache then ip cache
		2 tcp connects
		Ping connects - firewall / udp pong if in window
		
	If switched to Open Mode
		disconnect from proxies
				
	If Dht Cache and Open 
		Update buckets / refresh
			Start search for DhtID, random in requied bucket (Ping)
	
	Find self if not blocked
		For NAT host this is for finding closer proxies
		No need for NAT to refresh buckets, can easily ask proxy
			
Buddy List
	Get closest uncontacted buddy
		Start search for Dht id
		Ping Buddies
		cache alive buckets but replace them on startup easily
		cache ips of buddies and their proxies
		cache ips of proxies
		
Add Contact
	Check if host closer for any proxied nodes
		
Search
	Unlimited, but only 3 search packets per second
	Blocked nodes send search request to proxy
				
Firewall window
	first 5 mins of each hour
	
Shutdown
	Add nodes in Dht cache to IP cache


///////////////////////////////////////////////
// Sockets

UDP Receive
	Set connection type to NAT
	Update tcp connects in Block proxy mode
	
TCP Outbound Connect
	send ping
	on pong
		if need proxy
			Send Proxy Request
		else
			send bye
	
	if cant take anymore proxies send bye

TCP Incoming Conenct
	Set connection type to Open


///////////////////////////////////////////////
// Dht Packets

Bootstrap Request (BSR)
	Structure 
		Sender ID (SID) payload 8b key
		
	Send
		When Dht cache dead and pong received from same host
		
	Receive
		Send requester 20 nodes udp
		Send remote ip
		
Bootstrap Ack
    Set ip to remote ip
	Add returned nodes to Dht cache
	add source to Dht cache
	
Proxy Request
	// already sent in ping - Dht ID
 	Mode NAT or Firewall
	
Proxy Resonse
	Yes / No if slots available
	Alternate / closer contacts
	
Search Request
	Dht ID
	Target Dht ID
	add to Dht cache if fw flag not set
	set proxy info
	
Search Ack
	even if matching node in list, still give closest alts
	Contact List of closer nodes
	If connect to remote node proxy tag sent
	If recevied tcp 
		found - source tag added
		fail  - fail tag
	
Ping
	add to Dht ids
	firewall test flag
	send with test flag always if firewalled
	wont be over used because for nat and blocked nodes
		ping only sent on new connections and bootstrap
	if firewall flag not set, add to cache
	if firewall flag and connected tcp
			try connection to ip/port
				if connection add SenderID to Dht cache

Pong
	in this way remote ip is requested so attack cant reset whole net's ips
	if udp add to Dht ids
	if Dht cache dead send bootstrap
	
///////////////////////////////////////////////
// Buckets (Dht id cache)

each bucket tries to keep a list of 16 nodes from 16 sub-regions of the bucket
   the position in the sub-region is random
   this is done to prevent certain nodes on the network being passed to everyone
   and being relied on for routing

add contact to cache

go through buckets
	if distance mismatch or last bucket on stack
		if not bucket full
			check if can merge with previous bucket
			add
		if bucket last on stack and can be split
			split
			
create bucket
	create 16 slots
		contact list
		random ID in range
	depth
	
	
check for bucket merge when removing dead contacts

class structure

DhtRouting
	DhtBucket stack
		DepthMask
		BucketEntry[16]
			contact
			fit
			random
		

///////////////////////////////////////////////
// IM Packets

On find a buddy init a session with them

Session Request
	Requester's internal key
	Encoded Secret key or passing data back to the requester
	Name
	
Session Ack
	Encoded Secret key for passing data to acker
	
On Change proxy node
	Send Session update with new info
	
Message
	Ecoded Text
	
Message Ack


Application
	When receiving session request from unknown entity, they can choose whether to accept
	After talking with the person they can do add buddy which will add their key
	
/////////////////////////////////////////////////////////
// buddy session negotiation

check table if packet already received
	send another ack if it has

on ping
	delete address list
	set source and proxies

console display buddy sendtracker

add lastseen to buddyaddress

en / decrypting unique and sessionids

send session request
	include proxies
	session ID
	
receive session request
	if buddy id unkown
		send key request
	else
		call buddy receive request

receive key request
	set negotiating mode
	
	send key
	
receive key ack
	set setup mode

	add buddy to list
	ask user to accept/deny
	mark buddyid with decision
	
	if deny send session ack with deny
	if accept send sessionack accept
		send session request
	
buddy receive request
	send session ack
	if not denied 
		if no outbound key
			send session request
		else
			set session active	

send session ack
	Session ID
	
receive session ack
	if outbound and inbound key set
		call login event
		
timeout setup mode after 15 secs
	clear all settings
	
	
buddy sendpacket
	attach buddy packet with session id / ack id
	send packet and add to queue
		set which proxy was tried and the attempt #
		set next retry at +5
	
timer
	if nextretry for packet
		resend to proxy with lowest attempts
		2 attempts on each proxy
	
on response
	keep list of recently received ids to prevent conflict
	remove from packet queue
	calc response time for proxy
	
general packet buffer that waits for acks
timeout 5 secs waiting for ack session / ack chat / whatever and send to diff proxy

right on search find result/proxy send session request, dont worry bout 'performance' of local proxies, they are pinged
whatever proxy ack comes back on, preference for outgoing data if blocked
wait 5 seconds, then try other proxy, if timeout occurs switch next proxy to top of list
wait for ack of ID, do for all packets
